import { ThreeDOMCapability } from './api.js';
import { ModelGraft as ThreeJSModelGraft } from './facade/three-js/model-graft.js';
declare const $modelGraft: unique symbol;
declare const $port: unique symbol;
declare const $messageEventHandler: unique symbol;
declare const $onMessageEvent: unique symbol;
/**
 * A ModelGraftManipulator is an internal construct intended to consolidate
 * any mutations that operate on the backing scene graph. It can be thought
 * of as a host execution context counterpart to the ModelKernel in the scene
 * graph execution context.
 */
declare class ModelGraftManipulator {
    protected [$port]: MessagePort;
    protected [$modelGraft]: AnyModelGraft;
    protected [$messageEventHandler]: (event: MessageEvent) => void;
    constructor(modelGraft: AnyModelGraft, port: MessagePort);
    /**
     * Clean up internal state so that the ModelGraftManipulator can be properly
     * garbage collected.
     */
    dispose(): void;
    [$onMessageEvent](event: MessageEvent): void;
}
export declare type AnyModelGraft = ThreeJSModelGraft;
/**
 * Constructs and returns a string representing a fully-formed scene graph
 * execution context script, including context patching, capabilities and
 * scene graph API constructs.
 */
export declare const generateContextScriptSource: (capabilities?: readonly ThreeDOMCapability[]) => string;
declare const $worker: unique symbol;
declare const $workerInitializes: unique symbol;
declare const $modelGraftManipulator: unique symbol;
/**
 * A ThreeDOMExecutionContext is created in the host execution context that
 * wishes to invoke scripts in a specially crafted and carefully isolated
 * script context, referred to as the scene graph execution context. For
 * practical implementation purposes, the scene graph execution context is
 * a Worker whose global scope has been heavily patched before any custom
 * script is subsequently invoked in it.
 *
 * The ThreeDOMExecutionContext must be given a set of allowed capabilities
 * when it is created. The allowed capabilities cannot be changed after the
 * scene graph execution context has been established.
 */
export declare class ThreeDOMExecutionContext extends EventTarget {
    get worker(): Worker;
    protected [$worker]: Worker;
    protected [$workerInitializes]: Promise<MessagePort>;
    protected [$modelGraftManipulator]: ModelGraftManipulator | null;
    constructor(capabilities: Array<ThreeDOMCapability>);
    changeModel(modelGraft: AnyModelGraft | null): Promise<void>;
    /**
     * Evaluate an arbitrary chunk of script in the scene graph execution context.
     * The script is guaranteed to be evaluated after the scene graph execution
     * context is fully initialized. It is not guaranteed to be evaluated before
     * or after a Model is made available in the scene graph execution context.
     *
     * Note that web browsers do not universally support module scripts ("ESM") in
     * Workers, so for now all scripts must be valid non-module scripts.
     */
    eval(scriptSource: string): Promise<void>;
    /**
     * Terminates the scene graph execution context, closes the designated
     * messaging port and generally cleans up the ThreeDOMExecutionContext
     * so that it can be properly garbage collected.
     */
    terminate(): Promise<void>;
}
export {};
