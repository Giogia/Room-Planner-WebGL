/* @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { ThreeDOMMessageType } from '../protocol.js';
/**
 * A function that will be stringified and appended the a runtime-generated
 * execution context script to initialize the scene graph execution context.
 *
 * The sole reason for using this pattern is to enable sound type
 * checking while also providing for the ability to stringify the factory so
 * that it can be part of a runtime-generated Worker script.
 */
function initialize(ModelKernel, preservedContext) {
    let currentKernel = null;
    preservedContext.addEventListener('message', (event) => {
        const { data } = event;
        if (data && data.type && data.type === ThreeDOMMessageType.HANDSHAKE) {
            const globalPort = event.ports[0];
            globalPort.addEventListener('message', (event) => {
                const { data } = event;
                if (data && data.type) {
                    switch (data.type) {
                        // Instantiate a new ModelKernel, and notify the execution context
                        // of the new Model with a 'model-change' event:
                        case ThreeDOMMessageType.MODEL_CHANGE: {
                            const previousModel = currentKernel != null ? currentKernel.model : undefined;
                            const serialized = data.model;
                            const port = event.ports[0];
                            if (currentKernel != null) {
                                currentKernel.deactivate();
                            }
                            else if (serialized == null) {
                                // Do not proceed if transitioning from null to null
                                break;
                            }
                            if (serialized != null) {
                                currentKernel = new ModelKernel(port, serialized);
                                this.model = currentKernel.model;
                            }
                            else {
                                currentKernel = null;
                                this.model = undefined;
                            }
                            const modelChangeEvent = new Event('model-change');
                            modelChangeEvent.previousModel = previousModel;
                            modelChangeEvent.model = this.model;
                            this.dispatchEvent(modelChangeEvent);
                            break;
                        }
                        // Import an external script into the execution context:
                        case ThreeDOMMessageType.IMPORT_SCRIPT: {
                            const url = data.url;
                            if (url) {
                                preservedContext.importScripts(url);
                            }
                            break;
                        }
                    }
                }
            });
            globalPort.start();
            // Notify the host execution context that the scene graph execution
            // is ready:
            globalPort.postMessage({ type: ThreeDOMMessageType.CONTEXT_INITIALIZED });
        }
    });
}
/**
 * A factory that produces a stringified initializer function.
 */
export const generateInitializer = () => initialize.toString();
//# sourceMappingURL=generate-initializer.js.map