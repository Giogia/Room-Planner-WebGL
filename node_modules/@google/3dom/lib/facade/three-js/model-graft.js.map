{"version":3,"file":"model-graft.js","sourceRoot":"","sources":["../../../src/facade/three-js/model-graft.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;GAaG;;AAIH,OAAO,EAAC,KAAK,EAAC,MAAM,YAAY,CAAC;AAGjC,MAAM,MAAM,GAAG,MAAM,CAAC,OAAO,CAAC,CAAC;AAC/B,MAAM,qBAAqB,GAAG,MAAM,CAAC,sBAAsB,CAAC,CAAC;AAE7D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA+BG;AACH,MAAM,OAAO,UAAW,SAAQ,WAAW;IAKzC,YAAY,QAAgB,EAAE,IAAU;QACtC,KAAK,EAAE,CAAC;QAHF,QAAuB,GAAG,IAAI,GAAG,EAA2B,CAAC;QAInE,IAAI,CAAC,MAAM,CAAC,GAAG,IAAI,KAAK,CAAC,IAAI,EAAE,QAAQ,EAAE,IAAI,CAAC,CAAC;IACjD,CAAC;IAED,IAAI,KAAK;QACP,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC;IACtB,CAAC;IAED,sBAAsB,CAAC,EAAU;QAC/B,MAAM,OAAO,GAAG,IAAI,CAAC,qBAAqB,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;QAEpD,IAAI,OAAO,IAAI,IAAI,EAAE;YACnB,OAAO,IAAI,CAAC;SACb;QAED,OAAO,OAAO,CAAC;IACjB,CAAC;IAED,KAAK,CAAC,OAAwB;QAC5B,IAAI,CAAC,qBAAqB,CAAC,CAAC,GAAG,CAAC,OAAO,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;IAC/D,CAAC;IAED,MAAM,CAAC,EAAU,EAAE,QAAgB,EAAE,KAAc;QACjD,mEAAmE;QACnE,mEAAmE;QACnE,uEAAuE;QACvE,MAAM,OAAO,GAAG,IAAI,CAAC,sBAAsB,CAAC,EAAE,CAAC,CAAC;QAEhD,IAAI,OAAO,IAAI,IAAI,IAAI,QAAQ,IAAI,OAAO,EAAE;YACzC,OAAiD,CAAC,QAAQ,CAAC,GAAG,KAAK,CAAC;YAErE,IAAI,CAAC,aAAa,CACd,IAAI,WAAW,CAAC,UAAU,EAAE,EAAC,MAAM,EAAE,EAAC,OAAO,EAAE,OAAO,EAAC,EAAC,CAAC,CAAC,CAAC;SAChE;IACH,CAAC;CACF;KAtCU,qBAAqB","sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {GLTF} from 'three/examples/jsm/loaders/GLTFLoader.js';\n\nimport {Model} from './model.js';\nimport {ThreeDOMElement} from './three-dom-element.js';\n\nconst $model = Symbol('model');\nconst $elementsByInternalId = Symbol('elementsByInternalId');\n\n/**\n * ModelGraft\n *\n * This is a coordination primitive between a scene graph as represented by the\n * output for Three.js' GLTFLoader and a counterpart 3DOM facade. Since this is\n * the Three.js-specific implementation of the facade, the input is a GLTF-like\n * object whose keys refer to Three.js-specific constructs (e.g., gltf.scene is\n * a THREE.Scene).\n *\n * When created, the ModelGraft produces a Model that can be traversed and\n * manipulated to mutate the Three.js scene graph synchronously (but\n * indirectly). The benefit of this is that mutations to the Three.js scene can\n * be performed in a Three.js-agnostic fashion that is potentially portable to\n * alternative rendering backends.\n *\n * The scene graph representation produced by the ModelGraft is designed to\n * match the structures described in the glTF 2.0 spec as closely as possible.\n * Where there are deviations, it is usually for the purpose of making\n * synchronization easier, or else for ergonomics. For example, in glTF 2.0, the\n * graph is a series of flat arrays where nodes cross-reference each other by\n * index to represent hierarchy, but in a Model nodes have array members\n * containing refrences to their hierarchical children.\n *\n * An important goal of ModelGraft is to enable a scene in one JavaScript\n * context to be manipulated by script in a remote context, such as a distant\n * worker thread or even a different process. So, every node in the graph\n * is able to be serialized, and the serialized form includes an ID that is\n * locally unique to the ModelGraft instance that the node came from so that\n * the remote context can refer back to it. A ModelGraft can be thought of as\n * the host execution context counterpart to the ModelKernel in the scene graph\n * execution context.\n */\nexport class ModelGraft extends EventTarget {\n  protected[$model]: Model;\n\n  readonly[$elementsByInternalId] = new Map<number, ThreeDOMElement>();\n\n  constructor(modelUri: string, gltf: GLTF) {\n    super();\n    this[$model] = new Model(this, modelUri, gltf);\n  }\n\n  get model() {\n    return this[$model];\n  }\n\n  getElementByInternalId(id: number): ThreeDOMElement|null {\n    const element = this[$elementsByInternalId].get(id);\n\n    if (element == null) {\n      return null;\n    }\n\n    return element;\n  }\n\n  adopt(element: ThreeDOMElement) {\n    this[$elementsByInternalId].set(element.internalID, element);\n  }\n\n  mutate(id: number, property: string, value: unknown) {\n    // TODO(#1005): Manipulations probably need to be validated against\n    // allowed capabilities here. We already do this on the scene graph\n    // execution context side, but it would be safer to do it on both sides\n    const element = this.getElementByInternalId(id);\n\n    if (element != null && property in element) {\n      (element as unknown as {[index: string]: unknown})[property] = value;\n\n      this.dispatchEvent(\n          new CustomEvent('mutation', {detail: {element: element}}));\n    }\n  }\n}\n"]}