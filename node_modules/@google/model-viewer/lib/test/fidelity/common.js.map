{"version":3,"file":"common.js","sourceRoot":"","sources":["../../../src/test/fidelity/common.ts"],"names":[],"mappings":"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","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {colorDelta} from '../../third_party/pixelmatch/color-delta.js';\n\nexport interface OffscreenCanvas extends HTMLCanvasElement {}\n\nexport const COMPONENTS_PER_PIXEL: number = 4;\n\n// 35215 is the maximum possible value for the YIQ difference metric\n// @see https://github.com/mapbox/pixelmatch/blob/master/index.js#L14\n// @see http://www.progmat.uaem.mx:8080/artVol2Num2/Articulo3Vol2Num2.pdf\nexport const MAX_COLOR_DISTANCE: number = 35215;\n\nexport interface ImageComparisonAnalysis {\n  matchingRatio: number;\n  averageDistanceRatio: number;\n  mismatchingAverageDistanceRatio: number;\n}\n\nexport interface ImageComparisonResults {\n  analysis: ImageComparisonAnalysis;\n  imageBuffers: {delta: ArrayBuffer|null; blackWhite: ArrayBuffer | null;};\n}\n\nexport interface ImageComparisonMessage {\n  type: 'canvases-ready'|'images-assigned'|'threshold-changed'|\n      'analysis-completed';\n}\n\nexport interface CanvasesReadyMessage extends ImageComparisonMessage {\n  candidateCanvas: OffscreenCanvas;\n  goldenCanvas: OffscreenCanvas;\n  blackWhiteCanvas: OffscreenCanvas;\n  deltaCanvas: OffscreenCanvas;\n}\n\nexport interface ImagesAssignedMessage extends ImageComparisonMessage {\n  candidateImageBuffer: ArrayBuffer;\n  goldenImageBuffer: ArrayBuffer;\n  dimensions: Dimensions;\n}\n\nexport interface ThresholdChangedMessage extends ImageComparisonMessage {\n  threshold: number;\n}\n\nexport interface AnalysisCompletedMessage extends ImageComparisonMessage {\n  result: ImageComparisonResults\n}\n\nexport interface Dimensions {\n  width: number;\n  height: number;\n}\n\nexport interface Pixel {\n  x: number;\n  y: number;\n}\n\nexport interface Rect extends Dimensions {\n  x: number;\n  y: number;\n}\n\n\nexport interface ScenarioConfig {\n  name: string;\n  model: string;\n  lighting: string;\n  dimensions: Dimensions;\n  target: {x: number, y: number, z: number};\n  orbit: {theta: number, phi: number, radius: number};\n  verticalFoV: number;\n  exclude?: Array<string>;\n}\n\nexport interface RendererConfig {\n  name: string, description: string, scripts?: {setup: string}\n}\n\nexport interface GoldenConfig extends RendererConfig {\n  file: string;\n}\n\nexport interface ImageComparisonConfig {\n  rootDirectory: string;\n  analysisThresholds: Array<number>;\n  renderers: Array<RendererConfig>;\n  scenarios: Array<ScenarioConfig>;\n}\n\nexport interface ComparableImage {\n  [index: number]: number;\n  length: number;\n}\n\nexport interface AnalysisOptions {\n  generateVisuals: boolean;\n}\n\nexport class ImageComparator {\n  protected imagePixels: number;\n\n  constructor(\n      protected candidateImage: ComparableImage,\n      protected goldenImage: ComparableImage, readonly dimensions: Dimensions) {\n    const {width, height} = dimensions;\n\n    this.imagePixels = width * height;\n  }\n\n  protected drawPixel(\n      image: ComparableImage, position: number, r: number, g: number, b: number,\n      a: number = 255) {\n    image[position + 0] = r;\n    image[position + 1] = g;\n    image[position + 2] = b;\n    image[position + 3] = a;\n  }\n\n  analyze(threshold: number, options: AnalysisOptions = {\n    generateVisuals: true\n  }): ImageComparisonResults {\n    const {candidateImage, goldenImage} = this;\n    const {width, height} = this.dimensions;\n    const {generateVisuals} = options;\n\n    const blackWhiteImage = generateVisuals ?\n        new Uint8ClampedArray(this.imagePixels * COMPONENTS_PER_PIXEL) :\n        null;\n    const deltaImage = generateVisuals ?\n        new Uint8ClampedArray(this.imagePixels * COMPONENTS_PER_PIXEL) :\n        null;\n\n    const thresholdSquared = threshold * threshold;\n\n    let matched = 0;\n    let sum = 0;\n    let mismatchingSum = 0;\n    let maximumDeltaIntensity = 0;\n\n    if (candidateImage.length != goldenImage.length) {\n      throw new Error(`Image sizes do not match (candidate: ${\n          candidateImage.length}, golden: ${goldenImage.length})`);\n    }\n\n    for (let y = 0; y < height; ++y) {\n      for (let x = 0; x < width; ++x) {\n        const index = y * width + x;\n        const position = index * COMPONENTS_PER_PIXEL;\n        const delta =\n            colorDelta(candidateImage, goldenImage, position, position);\n        const exactlyMatched = (delta <= thresholdSquared ? 1 : 0) * 255;\n\n        if (exactlyMatched) {\n          matched++;\n        } else {\n          mismatchingSum += delta;\n        }\n\n        const thresholdDelta = Math.max(0, delta - thresholdSquared);\n\n        sum += thresholdDelta;\n\n        if (generateVisuals) {\n          const deltaIntensity =\n              Math.round(255 * thresholdDelta / MAX_COLOR_DISTANCE);\n\n          maximumDeltaIntensity =\n              Math.max(deltaIntensity, maximumDeltaIntensity);\n\n          this.drawPixel(\n              blackWhiteImage!,\n              position,\n              exactlyMatched,\n              exactlyMatched,\n              exactlyMatched);\n          this.drawPixel(\n              deltaImage!,\n              position,\n              255,\n              255 - deltaIntensity,\n              255 - deltaIntensity);\n        }\n      }\n    }\n\n    if (generateVisuals) {\n      for (let y = 0; y < height; ++y) {\n        for (let x = 0; x < width; ++x) {\n          const index = y * width + x;\n          const position = index * COMPONENTS_PER_PIXEL;\n          const absoluteDeltaIntensity = 255 - deltaImage![position + 1];\n          const relativeDeltaIntensity = Math.round(\n              255 - 255 * (absoluteDeltaIntensity / maximumDeltaIntensity));\n\n          this.drawPixel(\n              deltaImage!,\n              position,\n              255,\n              relativeDeltaIntensity,\n              relativeDeltaIntensity);\n        }\n      }\n    }\n\n    const mismatchingPixels = this.imagePixels - matched;\n\n    const mismatchingAverageDistanceRatio = mismatchingPixels > 0 ?\n        mismatchingSum / (this.imagePixels - matched) / MAX_COLOR_DISTANCE :\n        0;\n    const averageDistanceRatio = sum / this.imagePixels / MAX_COLOR_DISTANCE;\n\n    return {\n      analysis: {\n        matchingRatio: matched / this.imagePixels,\n        averageDistanceRatio,\n        mismatchingAverageDistanceRatio,\n      },\n      imageBuffers: {\n        delta: deltaImage ? deltaImage.buffer as ArrayBuffer : null,\n        blackWhite: blackWhiteImage ? blackWhiteImage.buffer as ArrayBuffer :\n                                      null\n      }\n    };\n  }\n}\n"]}