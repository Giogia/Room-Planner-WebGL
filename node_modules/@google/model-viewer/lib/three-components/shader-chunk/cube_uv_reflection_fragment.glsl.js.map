{"version":3,"file":"cube_uv_reflection_fragment.glsl.js","sourceRoot":"","sources":["../../../src/three-components/shader-chunk/cube_uv_reflection_fragment.glsl.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;GAaG;AAEH,OAAO,EAAC,YAAY,EAAE,UAAU,EAAC,MAAM,kBAAkB,CAAC;AAE1D,MAAM,CAAC,MAAM,mBAAmB,GAAG,UAAU,CAAC;;;;;EAK5C,YAAY;EACZ,UAAU;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAmCX,CAAC;AAEF,MAAM,CAAC,MAAM,WAAW,GAAG,UAAU,CAAC;;;EAGpC,mBAAmB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAqCpB,CAAC","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {getFaceChunk, getUVChunk} from './common.glsl.js';\n\nexport const bilinearCubeUVChunk = /* glsl */ `\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\n${getFaceChunk}\n${getUVChunk}\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n  float face = getFace(direction);\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n  mipInt = max(mipInt, cubeUV_minMipLevel);\n  float faceSize = exp2(mipInt);\n\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\n  vec2 f = fract(uv);\n  uv += 0.5 - f;\n  if (face > 2.0) {\n    uv.y += faceSize;\n    face -= 3.0;\n  }\n  uv.x += face * faceSize;\n  if(mipInt < cubeUV_maxMipLevel){\n    uv.y += 2.0 * cubeUV_maxTileSize;\n  }\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n  uv *= texelSize;\n\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x += texelSize;\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.y += texelSize;\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x -= texelSize;\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  vec3 tm = mix(tl, tr, f.x);\n  vec3 bm = mix(bl, br, f.x);\n  return mix(tm, bm, f.y);\n}\n`;\n\nexport const cubeUVChunk = /* glsl */ `\n#ifdef ENVMAP_TYPE_CUBE_UV\n\n${bilinearCubeUVChunk}\n\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\n  float filterMip = 0.0;\n  if (roughness >= 0.7) {\n    filterMip = (1.0 - roughness) / (1.0 - 0.7) - 5.0;\n  } else if (roughness >= 0.5) {\n    filterMip = (0.7 - roughness) / (0.7 - 0.5) - 4.0;\n  } else if (roughness >= 0.32) {\n    filterMip = (0.5 - roughness) / (0.5 - 0.32) - 3.0;\n  } else if (roughness >= 0.22) {\n    filterMip = (0.32 - roughness) / (0.32 - 0.22) - 2.0;\n  } else if (roughness >= 0.15) {\n    filterMip = (0.22 - roughness) / (0.22 - 0.15) - 1.0;\n  }\n\n  roughness = min(roughness, 0.15);\n  float sigma = PI * roughness * roughness / (1.0 + roughness);\n\n  // Add anti-aliasing mipmap contribution\n  vec3 dxy = max(abs(dFdx(sampleDir)), abs(dFdy(sampleDir)));\n  sigma += 0.5 * max(max(dxy.x, dxy.y), dxy.z);\n\n  float mip =\n      clamp(-log2(sigma), cubeUV_minMipLevel, cubeUV_maxMipLevel) + filterMip;\n  float mipF = fract(mip);\n  float mipInt = floor(mip);\n\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\n  if (mipF == 0.0) {\n    return vec4(color0, 1.0);\n  } else {\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\n    return vec4(mix(color0, color1, mipF), 1.0);\n  }\n}\n#endif\n`;\n"]}