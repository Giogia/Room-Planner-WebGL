{"version":3,"file":"common.glsl.js","sourceRoot":"","sources":["../../../src/three-components/shader-chunk/common.glsl.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;GAaG;AAEH,OAAO,EAAC,aAAa,EAAE,cAAc,EAAE,YAAY,EAAE,YAAY,EAAE,cAAc,EAAE,aAAa,EAAE,YAAY,EAAC,MAAM,OAAO,CAAC;AAE7H,OAAO,EAAC,gBAAgB,EAAC,MAAM,mCAAmC,CAAC;AAEnE,gFAAgF;AAChF,gFAAgF;AAChF,qDAAqD;AAErD,8EAA8E;AAC9E,8DAA8D;AAE9D,MAAM,CAAC,MAAM,iBAAiB,GAAG,UAAU,CAAC;;;;;;;;;;;;;;;;;;;;;CAqB3C,CAAC;AAEF,MAAM,CAAC,MAAM,YAAY,GAAG,UAAU,CAAC;;;;;;;;;;;;;;;;;CAiBtC,CAAC;AAEF,MAAM,CAAC,MAAM,UAAU,GAAG,UAAU,CAAC;;;;;;;;;;;;;;;;;;CAkBpC,CAAC;AAEF,MAAM,CAAC,MAAM,SAAS,GAAG;IACvB,CAAC,cAAc,CAAC,EAAE,CAAC;IACnB,CAAC,YAAY,CAAC,EAAE,CAAC;IACjB,CAAC,YAAY,CAAC,EAAE,CAAC;IACjB,CAAC,aAAa,CAAC,EAAE,CAAC;IAClB,CAAC,cAAc,CAAC,EAAE,CAAC;IACnB,CAAC,YAAY,CAAC,EAAE,CAAC;IACjB,CAAC,aAAa,CAAC,EAAE,CAAC;CACnB,CAAC;AAEF,MAAM,CAAC,MAAM,OAAO,GAAG,UAAU,CAAC;;;EAGhC,gBAAgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAmCjB,CAAC","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {GammaEncoding, LinearEncoding, RGBDEncoding, RGBEEncoding, RGBM16Encoding, RGBM7Encoding, sRGBEncoding} from 'three';\n\nimport {texelConversions} from './encodings_pars_fragment.glsl.js';\n\n// These shader functions convert between the UV coordinates of a single face of\n// a cubemap, the 0-5 integer index of a cube face, and the direction vector for\n// sampling a textureCube (not generally normalized).\n\n// getDirectionChunk handles uv coordinates that are beyond [0, 1] in either x\n// or y (not both) by wrapping around to the neighboring face.\n\nexport const getDirectionChunk = /* glsl */ `\nvec3 getDirection(vec2 uv, float face) {\n    uv = 2.0 * uv - 1.0;\n    vec3 direction = vec3(uv, 1.0);\n    if (face == 0.0) {\n      direction = direction.zyx;\n      direction.z *= -1.0;\n    } else if (face == 1.0) {\n      direction = direction.xzy;\n      direction.z *= -1.0;\n    } else if (face == 3.0) {\n      direction = direction.zyx;\n      direction.x *= -1.0;\n    } else if (face == 4.0) {\n      direction = direction.xzy;\n      direction.y *= -1.0;\n    } else if (face == 5.0) {\n      direction.xz *= -1.0;\n    }\n    return direction;\n}\n`;\n\nexport const getFaceChunk = /* glsl */ `\nfloat getFace(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    float face = -1.0;\n    if (absDirection.x > absDirection.z) {\n      if (absDirection.x > absDirection.y)\n        face = direction.x > 0.0 ? 0.0 : 3.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    } else {\n      if (absDirection.z > absDirection.y)\n        face = direction.z > 0.0 ? 2.0 : 5.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    }\n    return face;\n}\n`;\n\nexport const getUVChunk = /* glsl */ `\nvec2 getUV(vec3 direction, float face) {\n    vec2 uv;\n    if (face == 0.0) {\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);\n    } else if (face == 1.0) {\n      uv = vec2(direction.x, -direction.z) / abs(direction.y);\n    } else if (face == 2.0) {\n      uv = direction.xy / abs(direction.z);\n    } else if (face == 3.0) {\n      uv = vec2(direction.z, direction.y) / abs(direction.x);\n    } else if (face == 4.0) {\n      uv = direction.xz / abs(direction.y);\n    } else {\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);\n    }\n    return 0.5 * (uv + 1.0);\n}\n`;\n\nexport const encodings = {\n  [LinearEncoding]: 0,\n  [sRGBEncoding]: 1,\n  [RGBEEncoding]: 2,\n  [RGBM7Encoding]: 3,\n  [RGBM16Encoding]: 4,\n  [RGBDEncoding]: 5,\n  [GammaEncoding]: 6\n};\n\nexport const texelIO = /* glsl */ `\nuniform int inputEncoding;\nuniform int outputEncoding;\n${texelConversions}\nvec4 inputTexelToLinear(vec4 value){\n    if(inputEncoding == 0){\n        return value;\n    }else if(inputEncoding == 1){\n        return sRGBToLinear(value);\n    }else if(inputEncoding == 2){\n        return RGBEToLinear(value);\n    }else if(inputEncoding == 3){\n        return RGBMToLinear(value, 7.0);\n    }else if(inputEncoding == 4){\n        return RGBMToLinear(value, 16.0);\n    }else if(inputEncoding == 5){\n        return RGBDToLinear(value, 256.0);\n    }else{\n        return GammaToLinear(value, 2.2);\n    }\n}\nvec4 linearToOutputTexel(vec4 value){\n    if(outputEncoding == 0){\n        return value;\n    }else if(outputEncoding == 1){\n        return LinearTosRGB(value);\n    }else if(outputEncoding == 2){\n        return LinearToRGBE(value);\n    }else if(outputEncoding == 3){\n        return LinearToRGBM(value, 7.0);\n    }else if(outputEncoding == 4){\n        return LinearToRGBM(value, 16.0);\n    }else if(outputEncoding == 5){\n        return LinearToRGBD(value, 256.0);\n    }else{\n        return LinearToGamma(value, 2.2);\n    }\n}\n`;\n"]}