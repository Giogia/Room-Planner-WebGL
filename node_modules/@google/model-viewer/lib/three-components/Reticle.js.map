{"version":3,"file":"Reticle.js","sourceRoot":"","sources":["../../src/three-components/Reticle.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;GAaG;AAEH,OAAO,EAAS,IAAI,IAAI,SAAS,EAAE,OAAO,EAAE,IAAI,EAAE,iBAAiB,EAAE,QAAQ,EAAE,SAAS,EAAE,YAAY,EAAE,OAAO,GAAE,MAAM,OAAO,CAAC;AAE/H;;;;GAIG;AACH,MAAM,CAAC,OAAO,OAAO,OAAQ,SAAQ,QAAQ;IAK3C;;;OAGG;IACH,YAAY,MAAc;QACxB,KAAK,EAAE,CAAC;QAPF,cAAS,GAAmB,IAAI,CAAC;QASvC,IAAI,CAAC,IAAI,GAAG,SAAS,CAAC;QAEtB,IAAI,QAAQ,GAAG,IAAI,YAAY,CAAC,GAAG,EAAE,IAAI,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC;QAClD,IAAI,QAAQ,GAAG,IAAI,iBAAiB,CAAC,EAAC,KAAK,EAAE,QAAQ,EAAC,CAAC,CAAC;QACxD,sEAAsE;QACtE,QAAQ,CAAC,WAAW,CAAC,IAAI,OAAO,EAAE,CAAC,aAAa,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QAE3E,IAAI,CAAC,IAAI,GAAG,IAAI,IAAI,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;QAEzC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAEpB,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;QACrB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;IACvB,CAAC;IAED;;;;;;OAMG;IACH,KAAK,CAAC,MAAM,CAAC,OAAkB,EAAE,UAA8B;QAC7D,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,SAAS,IAAI,IAAI,SAAS,EAAE,CAAC;QACnD,IAAI,CAAC,SAAS,CAAC,aAAa,CAAC,EAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAC,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;QACxD,MAAM,GAAG,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC;QAC/B,IAAI,KAAK,GAAU,IAAI,KAAK,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,CAAC,SAAS,CAAC,CAAC;QAExD,IAAI,IAAwB,CAAC;QAE7B,IAAI;YACF,IAAI,GAAG,MAAM,OAAO,CAAC,cAAc,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC;SACxD;QAAC,OAAO,KAAK,EAAE;YACd,IAAI,GAAG,EAAE,CAAC;SACX;QAED,IAAI,IAAI,CAAC,MAAM,EAAE;YACf,MAAM,GAAG,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;YACpB,MAAM,SAAS,GAAG,IAAI,OAAO,EAAE,CAAC,SAAS,CAAC,GAAG,CAAC,SAAgB,CAAC,CAAC;YAEhE,2DAA2D;YAC3D,IAAI,CAAC,QAAQ,CAAC,qBAAqB,CAAC,SAAS,CAAC,CAAC;YAE/C,uCAAuC;YACvC,MAAM,SAAS,GACX,IAAI,OAAO,EAAE,CAAC,qBAAqB,CAAC,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;YACjE,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CACpB,SAAS,CAAC,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;YAClE,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC,CAAC;YAE/B,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;SACrB;IACH,CAAC;CACF","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Camera, Math as ThreeMath, Matrix4, Mesh, MeshBasicMaterial, Object3D, Raycaster, RingGeometry, Vector3,} from 'three';\n\n/**\n * The Reticle class creates an object that repeatedly calls\n * `xrSession.requestHitTest()` to render a ring along a found\n * horizontal surface.\n */\nexport default class Reticle extends Object3D {\n  private ring: Mesh;\n  private camera: Camera;\n  private raycaster: Raycaster|null = null;\n\n  /**\n   * @param {XRSession} xrSession\n   * @param {THREE.Camera} camera\n   */\n  constructor(camera: Camera) {\n    super();\n\n    this.name = 'Reticle';\n\n    let geometry = new RingGeometry(0.1, 0.11, 24, 1);\n    let material = new MeshBasicMaterial({color: 0xffffff});\n    // Orient the geometry so its position is flat on a horizontal surface\n    geometry.applyMatrix(new Matrix4().makeRotationX(ThreeMath.degToRad(-90)));\n\n    this.ring = new Mesh(geometry, material);\n\n    this.add(this.ring);\n\n    this.visible = false;\n    this.camera = camera;\n  }\n\n  /**\n   * Fires a hit test in the middle of the screen and places the reticle\n   * upon the surface if found.\n   *\n   * @param {XRSession} session\n   * @param {XRFrameOfReference} frameOfRef\n   */\n  async update(session: XRSession, frameOfRef: XRFrameOfReference) {\n    this.raycaster = this.raycaster || new Raycaster();\n    this.raycaster.setFromCamera({x: 0, y: 0}, this.camera);\n    const ray = this.raycaster.ray;\n    let xrray: XRRay = new XRRay(ray.origin, ray.direction);\n\n    let hits: Array<XRHitResult>;\n\n    try {\n      hits = await session.requestHitTest(xrray, frameOfRef);\n    } catch (error) {\n      hits = [];\n    }\n\n    if (hits.length) {\n      const hit = hits[0];\n      const hitMatrix = new Matrix4().fromArray(hit.hitMatrix as any);\n\n      // Now apply the position from the hitMatrix onto our model\n      this.position.setFromMatrixPosition(hitMatrix);\n\n      // Rotate the anchor to face the camera\n      const targetPos =\n          new Vector3().setFromMatrixPosition(this.camera.matrixWorld);\n      const angle = Math.atan2(\n          targetPos.x - this.position.x, targetPos.z - this.position.z);\n      this.rotation.set(0, angle, 0);\n\n      this.visible = true;\n    }\n  }\n}\n"]}