import _regeneratorRuntime from "@babel/runtime/regenerator";
import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import { isLoaderObject } from './loader-utils/normalize-loader';
import { mergeOptions } from './loader-utils/merge-options';
import { getIteratorFromData } from './loader-utils/get-data';
import { getLoaderContext } from './loader-utils/get-loader-context';
import { selectLoader } from './select-loader';
export function parseInBatchesSync(_x, _x2, _x3, _x4) {
  return _parseInBatchesSync.apply(this, arguments);
}

function _parseInBatchesSync() {
  _parseInBatchesSync = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(data, loaders, options, url) {
    var loader, context;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {
              url = options;
              options = loaders;
              loaders = null;
            }

            loader = selectLoader(loaders, url, null);
            options = mergeOptions(loader, options);
            context = getLoaderContext({
              url: url,
              loaders: loaders
            }, options);
            return _context.abrupt("return", parseWithLoaderInBatchesSync(loader, data, options, context));

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _parseInBatchesSync.apply(this, arguments);
}

function parseWithLoaderInBatchesSync(loader, data, options, context) {
  if (loader.parseInBatchesSync) {
    var inputIterator = getIteratorFromData(data);
    var outputIterator = loader.parseInBatchesSync(inputIterator, options, context, loader);
    return outputIterator;
  }

  throw new Error('parseWithLoaderInBatchesSync not available');
}
//# sourceMappingURL=parse-in-batches-sync.js.map