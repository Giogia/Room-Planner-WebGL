import _awaitAsyncGenerator from "@babel/runtime/helpers/esm/awaitAsyncGenerator";
import _wrapAsyncGenerator from "@babel/runtime/helpers/esm/wrapAsyncGenerator";
import _asyncIterator from "@babel/runtime/helpers/esm/asyncIterator";
import { concatenateArrayBuffers } from '../javascript-utils/memory-copy-utils';
export async function forEach(iterator, visitor) {
  while (true) {
    const {
      done,
      value
    } = await iterator.next();

    if (done) {
      iterator.return();
      return;
    }

    const cancel = visitor(value);

    if (cancel) {
      return;
    }
  }
}
export async function concatenateAsyncIterator(asyncIterator) {
  let arrayBuffer = new ArrayBuffer();
  let string = '';
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;

  var _iteratorError;

  try {
    for (var _iterator = _asyncIterator(asyncIterator), _step, _value; _step = await _iterator.next(), _iteratorNormalCompletion = _step.done, _value = await _step.value, !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {
      const chunk = _value;

      if (typeof chunk === 'string') {
        string += chunk;
      } else {
        arrayBuffer = concatenateArrayBuffers(arrayBuffer, chunk);
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        await _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return string || arrayBuffer;
}
export function textDecoderAsyncIterator(_x, _x2) {
  return _textDecoderAsyncIterator.apply(this, arguments);
}

function _textDecoderAsyncIterator() {
  _textDecoderAsyncIterator = _wrapAsyncGenerator(function* (arrayBufferIterator, options) {
    const textDecoder = new TextDecoder(options);
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;

    var _iteratorError2;

    try {
      for (var _iterator2 = _asyncIterator(arrayBufferIterator), _step2, _value2; _step2 = yield _awaitAsyncGenerator(_iterator2.next()), _iteratorNormalCompletion2 = _step2.done, _value2 = yield _awaitAsyncGenerator(_step2.value), !_iteratorNormalCompletion2; _iteratorNormalCompletion2 = true) {
        const arrayBuffer = _value2;
        yield typeof arrayBuffer === 'string' ? arrayBuffer : textDecoder.decode(arrayBuffer, {
          stream: true
        });
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          yield _awaitAsyncGenerator(_iterator2.return());
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  });
  return _textDecoderAsyncIterator.apply(this, arguments);
}

export function textEncoderAsyncIterator(_x3, _x4) {
  return _textEncoderAsyncIterator.apply(this, arguments);
}

function _textEncoderAsyncIterator() {
  _textEncoderAsyncIterator = _wrapAsyncGenerator(function* (textIterator, options) {
    const textEncoder = new TextEncoder();
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;

    var _iteratorError3;

    try {
      for (var _iterator3 = _asyncIterator(textIterator), _step3, _value3; _step3 = yield _awaitAsyncGenerator(_iterator3.next()), _iteratorNormalCompletion3 = _step3.done, _value3 = yield _awaitAsyncGenerator(_step3.value), !_iteratorNormalCompletion3; _iteratorNormalCompletion3 = true) {
        const text = _value3;
        yield typeof text === 'string' ? textEncoder.encode(text) : text;
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
          yield _awaitAsyncGenerator(_iterator3.return());
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }
  });
  return _textEncoderAsyncIterator.apply(this, arguments);
}

export function lineAsyncIterator(_x5) {
  return _lineAsyncIterator.apply(this, arguments);
}

function _lineAsyncIterator() {
  _lineAsyncIterator = _wrapAsyncGenerator(function* (textIterator) {
    let previous = '';
    var _iteratorNormalCompletion4 = true;
    var _didIteratorError4 = false;

    var _iteratorError4;

    try {
      for (var _iterator4 = _asyncIterator(textIterator), _step4, _value4; _step4 = yield _awaitAsyncGenerator(_iterator4.next()), _iteratorNormalCompletion4 = _step4.done, _value4 = yield _awaitAsyncGenerator(_step4.value), !_iteratorNormalCompletion4; _iteratorNormalCompletion4 = true) {
        const textChunk = _value4;
        previous += textChunk;
        let eolIndex;

        while ((eolIndex = previous.indexOf('\n')) >= 0) {
          const line = previous.slice(0, eolIndex + 1);
          previous = previous.slice(eolIndex + 1);
          yield line;
        }
      }
    } catch (err) {
      _didIteratorError4 = true;
      _iteratorError4 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
          yield _awaitAsyncGenerator(_iterator4.return());
        }
      } finally {
        if (_didIteratorError4) {
          throw _iteratorError4;
        }
      }
    }

    if (previous.length > 0) {
      yield previous;
    }
  });
  return _lineAsyncIterator.apply(this, arguments);
}

export function numberedLineAsyncIterator(_x6) {
  return _numberedLineAsyncIterator.apply(this, arguments);
}

function _numberedLineAsyncIterator() {
  _numberedLineAsyncIterator = _wrapAsyncGenerator(function* (lineIterator) {
    let counter = 1;
    var _iteratorNormalCompletion5 = true;
    var _didIteratorError5 = false;

    var _iteratorError5;

    try {
      for (var _iterator5 = _asyncIterator(lineIterator), _step5, _value5; _step5 = yield _awaitAsyncGenerator(_iterator5.next()), _iteratorNormalCompletion5 = _step5.done, _value5 = yield _awaitAsyncGenerator(_step5.value), !_iteratorNormalCompletion5; _iteratorNormalCompletion5 = true) {
        const line = _value5;
        yield {
          counter,
          line
        };
        counter++;
      }
    } catch (err) {
      _didIteratorError5 = true;
      _iteratorError5 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
          yield _awaitAsyncGenerator(_iterator5.return());
        }
      } finally {
        if (_didIteratorError5) {
          throw _iteratorError5;
        }
      }
    }
  });
  return _numberedLineAsyncIterator.apply(this, arguments);
}
//# sourceMappingURL=async-iterator-utils.js.map