"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decode = decode;
exports.encode = encode;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _loaderUtils = require("@loaders.gl/loader-utils");

var _gltfScenegraph = _interopRequireDefault(require("../gltf-scenegraph"));

var _gltfConstants = require("../gltf-constants");

var _gltfAttributeUtils = require("../gltf-utils/gltf-attribute-utils");

var _marked = _regenerator["default"].mark(meshPrimitiveIterator);

function decode(_x, _x2, _x3) {
  return _decode.apply(this, arguments);
}

function _decode() {
  _decode = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee(gltfData, options, context) {
    var scenegraph, promises, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, primitive;

    return _regenerator["default"].wrap(function _callee$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (options.gltf.decompressMeshes) {
              _context2.next = 2;
              break;
            }

            return _context2.abrupt("return");

          case 2:
            scenegraph = new _gltfScenegraph["default"](gltfData);
            promises = [];
            _iteratorNormalCompletion4 = true;
            _didIteratorError4 = false;
            _iteratorError4 = undefined;
            _context2.prev = 7;

            for (_iterator4 = meshPrimitiveIterator(scenegraph)[Symbol.iterator](); !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              primitive = _step4.value;

              if (scenegraph.getObjectExtension(primitive, _gltfConstants.KHR_DRACO_MESH_COMPRESSION)) {
                promises.push(decompressPrimitive(primitive, scenegraph, options, context));
              }
            }

            _context2.next = 15;
            break;

          case 11:
            _context2.prev = 11;
            _context2.t0 = _context2["catch"](7);
            _didIteratorError4 = true;
            _iteratorError4 = _context2.t0;

          case 15:
            _context2.prev = 15;
            _context2.prev = 16;

            if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
              _iterator4["return"]();
            }

          case 18:
            _context2.prev = 18;

            if (!_didIteratorError4) {
              _context2.next = 21;
              break;
            }

            throw _iteratorError4;

          case 21:
            return _context2.finish(18);

          case 22:
            return _context2.finish(15);

          case 23:
            _context2.next = 25;
            return Promise.all(promises);

          case 25:
            scenegraph.removeExtension(_gltfConstants.KHR_DRACO_MESH_COMPRESSION);

          case 26:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee, null, [[7, 11, 15, 23], [16,, 18, 22]]);
  }));
  return _decode.apply(this, arguments);
}

function encode(gltfData) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var scenegraph = new _gltfScenegraph["default"](gltfData);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (scenegraph.json.meshes || [])[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var mesh = _step.value;
      compressMesh(mesh, options);
      scenegraph.addRequiredExtension(_gltfConstants.KHR_DRACO_MESH_COMPRESSION);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}

function decompressPrimitive(_x4, _x5, _x6, _x7) {
  return _decompressPrimitive.apply(this, arguments);
}

function _decompressPrimitive() {
  _decompressPrimitive = (0, _asyncToGenerator2["default"])(_regenerator["default"].mark(function _callee2(primitive, scenegraph, options, context) {
    var compressedPrimitive, buffer, bufferCopy, parse, decodedData;
    return _regenerator["default"].wrap(function _callee2$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            compressedPrimitive = scenegraph.getObjectExtension(primitive, _gltfConstants.KHR_DRACO_MESH_COMPRESSION);
            buffer = scenegraph.getTypedArrayForBufferView(compressedPrimitive.bufferView);
            bufferCopy = (0, _loaderUtils.getZeroOffsetArrayBuffer)(buffer.buffer, buffer.byteOffset);
            parse = context.parse;
            _context3.next = 6;
            return parse(bufferCopy, [], options, context);

          case 6:
            decodedData = _context3.sent;
            primitive.attributes = (0, _gltfAttributeUtils.getGLTFAccessors)(decodedData.attributes);

            if (decodedData.indices) {
              primitive.indices = (0, _gltfAttributeUtils.getGLTFAccessor)(decodedData.indices);
            }

            checkPrimitive(primitive);

          case 10:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee2);
  }));
  return _decompressPrimitive.apply(this, arguments);
}

function compressMesh(attributes, indices) {
  var mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;
  var options = arguments.length > 3 ? arguments[3] : undefined;
  var context = arguments.length > 4 ? arguments[4] : undefined;

  if (!options.DracoWriter || !options.DracoLoader) {
    throw new Error('DracoWriter/DracoLoader not available');
  }

  var compressedData = options.DracoWriter.encodeSync({
    attributes: attributes
  });
  var parseSync = context.parseSync;
  var decodedData = parseSync({
    attributes: attributes
  });

  var fauxAccessors = options._addFauxAttributes(decodedData.attributes);

  var bufferViewIndex = options.addBufferView(compressedData);
  var glTFMesh = {
    primitives: [{
      attributes: fauxAccessors,
      mode: mode,
      extensions: (0, _defineProperty2["default"])({}, _gltfConstants.KHR_DRACO_MESH_COMPRESSION, {
        bufferView: bufferViewIndex,
        attributes: fauxAccessors
      })
    }]
  };
  return glTFMesh;
}

function checkPrimitive(primitive) {
  if (!primitive.attributes && Object.keys(primitive.attributes).length > 0) {
    throw new Error('Empty glTF primitive detected: Draco decompression failure?');
  }
}

function meshPrimitiveIterator(scenegraph) {
  var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, mesh, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, primitive;

  return _regenerator["default"].wrap(function meshPrimitiveIterator$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _iteratorNormalCompletion2 = true;
          _didIteratorError2 = false;
          _iteratorError2 = undefined;
          _context.prev = 3;
          _iterator2 = (scenegraph.json.meshes || [])[Symbol.iterator]();

        case 5:
          if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
            _context.next = 36;
            break;
          }

          mesh = _step2.value;
          _iteratorNormalCompletion3 = true;
          _didIteratorError3 = false;
          _iteratorError3 = undefined;
          _context.prev = 10;
          _iterator3 = mesh.primitives[Symbol.iterator]();

        case 12:
          if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
            _context.next = 19;
            break;
          }

          primitive = _step3.value;
          _context.next = 16;
          return primitive;

        case 16:
          _iteratorNormalCompletion3 = true;
          _context.next = 12;
          break;

        case 19:
          _context.next = 25;
          break;

        case 21:
          _context.prev = 21;
          _context.t0 = _context["catch"](10);
          _didIteratorError3 = true;
          _iteratorError3 = _context.t0;

        case 25:
          _context.prev = 25;
          _context.prev = 26;

          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }

        case 28:
          _context.prev = 28;

          if (!_didIteratorError3) {
            _context.next = 31;
            break;
          }

          throw _iteratorError3;

        case 31:
          return _context.finish(28);

        case 32:
          return _context.finish(25);

        case 33:
          _iteratorNormalCompletion2 = true;
          _context.next = 5;
          break;

        case 36:
          _context.next = 42;
          break;

        case 38:
          _context.prev = 38;
          _context.t1 = _context["catch"](3);
          _didIteratorError2 = true;
          _iteratorError2 = _context.t1;

        case 42:
          _context.prev = 42;
          _context.prev = 43;

          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }

        case 45:
          _context.prev = 45;

          if (!_didIteratorError2) {
            _context.next = 48;
            break;
          }

          throw _iteratorError2;

        case 48:
          return _context.finish(45);

        case 49:
          return _context.finish(42);

        case 50:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, null, [[3, 38, 42, 50], [10, 21, 25, 33], [26,, 28, 32], [43,, 45, 49]]);
}
//# sourceMappingURL=KHR_draco_mesh_compression.js.map